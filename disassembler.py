#!/usr/bin/env python

import uncompyle6
import dis
import sys
import os
import marshal

#disassemble .pyc file.
def disassemble_file_pyc(filename, mode):
    #user guide/help
    if mode == 'h' or mode == 'Help':
        show_help()
     
    #disassemble bytecode from a Python compiled file (.pyc)   
    elif mode == 'd' or mode == 'Disassemble':
        with open(filename, 'rb') as f:
         f.seek(16)
         dis.disassemble(marshal.load(f))  
    #reads the entire file into memory including the header
    elif mode == 'r' or mode == 'Read':
        with open(filename, 'rb') as f:
          magic = f.read(4) # read the magic number
          moddate = f.read(4) # read the modification timestamp
          code = f.read() # read the bytecode
        dis.dis(code)

    #displays a human-readable interpretation of the bytecode instructions
    elif mode == 'D' or mode == 'Display':
        with open(filename, "rb") as f:
           f.seek(16)
           dis.show_code(marshal.load(f))  
           
    #bytecode instructions that the Python interpreter would execute when running the program
    elif mode == 'i' or mode == 'instructions':   
        with open(filename, 'rb') as f:
            f.seek(16)
            code = marshal.load(f)
            instructions = dis.get_instructions(code)
            for instr in instructions:
                print(instr)    

    #find the offsets which are starts of lines in the source code              
    elif mode == 'f' or mode == 'Find':
        with open(filename, "rb") as f:
            code_str = f.read()
        code_obj = marshal.loads(code_str[16:])  # skip first 16 bytes (magic number and timestamp)
        print(dis.findlinestarts(code_obj))
                             
    else:
        print("Invalid mode: -[OPTION] ")
        show_help()
        
        
#disassemble .py file.      
def disassemble_file_py(filename, mode):
    #user guide/help
    if mode == 'h' or mode == 'Help':
        show_help()

    #disassemble bytecode from a Python compiled file (.pyc)           
    elif mode == 'd' or mode == 'Disassemble':
        with open(filename, "rb") as f:
           code_str = f.read()
        code_obj = compile(code_str, filename, "exec")
        dis.disassemble(code_obj)     

    #reads the entire file into memory including the header                
    elif mode == 'r' or mode == 'Read':
        with open(filename, 'rb') as f:
          magic = f.read(4) # read the magic number
          moddate = f.read(4) # read the modification timestamp
          code = f.read() # read the bytecode
        dis.dis(code)

    #displays a human-readable interpretation of the bytecode instructions
    elif mode == 'D' or mode == 'Display':
        with open(filename, "rb") as f:
           code_str = f.read()
        code_obj = compile(code_str, filename, "exec")
        dis.show_code(code_obj) 

    #bytecode instructions that the Python interpreter would execute when running the program
    elif mode == 'i' or mode == 'instructions:
        with open(filename, "rb") as f:
            code_str = f.read()
        code_obj = compile(code_str, filename, "exec")
        instructions = dis.get_instructions(code_obj)
        for instr in instructions:
            print(instr) 

    #find the offsets which are starts of lines in the source code              
    elif mode == 'f' or mode == 'Find':
        with open(filename, "rb") as f:
           code_str = f.read()
        code_obj = compile(code_str, filename, "exec")
        print(dis.findlinestarts(code_obj))             
 
    else:
        print("Invalid mode: -[OPTION] ")
        show_help()
        
#usage and help information about the disassembler tool        
def show_help():
    print()
    print("Usage: ./disassembler.py -[OPTION] FILE.pyc or FILE.py\n")
    print("\tFormat: $./disassembler -[option] [filename].pyc or .py\n")
    print("  Options: for both .pyc file and .py file\n")
    print("\t--h/--Help\t\tShow this help message\n")
    print("\t--d,  --Disassemble\tDisassemble bytecode from a Python.")
    print("\t--r,  --Read\t\tReads the entire file into memory.")
    print("\t--D,  --Display\t\tDisplays a human-readable interpretation of the bytecode instructions.")
    print("\t--i,  --Instructions\tBytecode instructions that the Python interpreter would execute when running the program.")
    print("\t--f,  --Find\t\tFind the offsets which are starts of lines in the source code.")
    sys.exit(1)
    

if __name__ == '__main__':
    #Check if no arguments are provided or the name of the program is incorrect
    if len(sys.argv) == 1  and sys.argv[0] == "./disassembler.py":
       show_help()
       sys.exit(1)
       
    #Get the mode argument and check if the correct number of arguments is provided
    mode = sys.argv[1][:2]
    if len(sys.argv) != 3 or mode != "--":
       show_help()
       sys.exit(2)
       
    #Get the filename argument and check if it exists   
    filename = sys.argv[2] 
    if not os.path.isfile(filename):
         print(f"Error: file '{filename}': Could not open the binary for disassembly!")
         sys.exit(3)
         
    #If all arguments are correct, disassemble the file using the specified mode     
    if len(sys.argv) == 3:
        mode = sys.argv[1].lstrip("--")
        if sys.argv[2][-2:] == "yc": #.pyc file
          disassemble_file_pyc(filename, mode)
        else:
          disassemble_file_py(filename, mode)  #.py file
    else:
        print("Invalid arguments. Usage: python3 disassembler.py -[option] filename")

